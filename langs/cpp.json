[
  {
    "name": "Entry point",
    "info": "De locatie waar een c/c++ programma start",
    "content": "int main{\n    //entry point\n}"
  },
  {
    "name": "Variables",
    "info": "C++ primitieve variabelen",
    "content":  "int main{\n    int i =5; //integer\n    float f= 3.5f;\n    double d = 5.0;\n    char c= 'C';\n    std::string = \"This is a string\";\n}"
  },
  {
    "name": "Pointers",
    "info": "pointer point to the memory location of a variable",
    "content": "#include <iostream>\n\nint main{\n\n        //create a pointer to an int object (on the heap)\n        int* ptr;\n        //normal stack based object\n        int val = 5;\n        //return the memory address of val and give it to the pointer\n        ptr = &val;\n        //dereference the pointer and use it like a normal variable\n        (*ptr) = 5;\n\n\n        std::string* Strptr;\n        std::string append = \"hello\";\n        Strptr = &append; // strptr points to hello\n        Strptr->append(append); //access methods via -> operator (append now equals hellohello)\n\n        //delete pointers because they live on the heap\n        delete ptr;\n        delete Strptr;\n}"
  },
  {
    "name": "Smart pointer",
    "info": "pointers used to prevent memory leakage",
    "content": "#include <memory> // used for shared_ptr, weak_ptr and unique_ptr\n\nclass entity\n{\npublic:\n    entity();\n    ~entity();\n\nprivate:\n\n};\n\nentity::entity()\n{\n}\n\nentity::~entity()\n{\n}\n\n\n\nint main(){\n    {\n            std::unique_ptr<entity> hello = std::make_unique<entity>();\n        }//this pointer gets deleted after this scope we also only have one pointer pointing to this reference\n\n        {\n            std::shared_ptr<entity> hi = std::make_shared<entity>();\n        //this pointer gets deleted after the scope and the value gets deleted after all shared pointers get deleted\n\n        \n            std::weak_ptr<entity> hio = hi; // a weak ptr is like a shared ptr but if all shared ptr are away the weak pointer won't point to anything\n        }//this pointer gets deleted after the scope and the value gets deleted after all shared pointers get deleted\n}"
  },
  {
    "name": "Arrays",
    "info": "An array is a series of elements of the same type placed in contiguous memory locations that can be individually referenced by adding an index to a unique identifier.",
    "content": "int main{\n\n    /* Stack based array */\n    int foo[5]; //Array on the stack containing 5 variables (not filled yet)\n    int foo [5] = { 16, 2, 77, 40, 12071 }; // this time declared with default variables\n    int jimmy [3][5]; // multi dimensional arrayÂµ\n\n    /* heap based array */\n    int* HeapArray = new int[size]; //heap based arrays can be created during runtime (they don't have a fixed size)\n    HeapArray[3] = 5;//setting element 4 of the array to 5\n    delete HeapArray[] //free space after you are finished\n}"
  },
  {
    "name": "The stack and the heap",
    "info": "Different ways to allocate memory",
    "content": "int main{\n    {\n        //stack based objects work with a stack\n        //you can only look at the top most variable\n        //like a stack of plates you can only take the top plate of\n        //stack variables are variables that don't use the new keyword or use pointers\n        int a = 5 //stack\n        Hero tom(25,150); //stack \n        Hero tim = new Hero(25,150); //heap based\n    }//the scope ended and the compiler pop's everything of the stack in this scope\n    //only tim remains alive the rest have there destructors called\n\n    //heap based objects are located randomly in memory and can be accessed by pointers only\n    Hero tim = new Hero(25,150); // tim is a pointer\n    tim->setHealth(800); // use as a pointer\n\n    delete tim; // you must delete it manualy (unless you use smart pointers)\n}\n\n\n"
  },
  {
    "name": "Compiler and linker",
    "info": "De locatie waar een c/c++ programma start",
    "content": "//A cpp program goes thru multiple stages before it is machine code\n//You must know these stagesin order to tune programs to perfection\n\n//first you have your source code\n\nint main(){\n    int i = 5;\n    return i;\n}\n\n//the preprocessor converts this code too your liking \n//and gives that source to the compiler\n\n//then the compiler will compile each translation unit into .obj files\n//these files are in binary\n\n//the next stage the linker will look at each declaration (usually in the header files)\n//and add the function itself in those translation units\n//It will also resolve external librarys (static and dynamic)\n\n//after this stage you will get you executable\n\n\n"
  },
  {
    "name": "For Loop",
    "info": "A for loop can be run x amount of times",
    "content": "int main{\n\n    for(int i=0;i<5;i++){\n        //this gets run 5 times\n        std::cout << i << std::endl;\n    }\n}"
  },
  {
    "name": "While",
    "info": "A loop that keeps running until a condition is true",
    "content": "int main{\n\n    int i = 0;\n    while(i<5){\n        //do logic here\n        //this runs 5 times\n        i++;\n    }\n}"
  },
  {
    "name": "If",
    "info": "A statement for defining logic",
    "content": "int main{\n\n    if(condition1){\n        //Only runs when condition1 == true\n    }else if (condition2){\n    //only runs when condition1 == false && condition2 == true\n    }else{\n        runs when every condition is false\n    }\n}"
  },
  {
    "name": "Tenary operator",
    "info": "This operator is a short had notation of an if statement",
    "content": "int a = 0;\ntrue == false ? a = 1 : a = 2; // a = 2 since true == false is false\n\n//tenary operator is like an if statement\ncondition ? statemen1 : statement2;\n\n//comparible if statement\nif(condition){\n    statement1\n}else{\n    statement2\n}"
  },
  {
    "name": "Logic Operators",
    "info": "used for boolean expressions",
    "content": "<  //smaller than\n>  //greater than\n<=  //smaller than or equal to\n>=  //greater than or equal to\n!=  //not equal to\n==  //same value\nx && y  //and gate between X and Y\nx && y  //and gate between X and Y\nx & y  //and gate between X and Y (bitwise)\nx | y  //and gate between X and Y (bitwise)\n~x //first compliment of x"
  },
  {
    "name": "Switch",
    "info": "Short hand notation for an if statement (only ==)",
    "content": "int main{\n\n    switch ('A')\n    {\n        case 'A':\n            std::cout << \"it's A\" << std::endl;\n            break;\n        case 'B':\n            std::cout << \"it's B\" << std::endl;\n            break;\n        default:\n            std::cout << \"It's neither A nor B\" << std::endl;\n            break;\n    }\n}"
  },
  {
    "name": "Functions",
    "info": "Blocks of code which you can repeat",
    "content": "#include <iostream>\n\n/* Static because we only want one instance of this function (no objects)*/\nstatic void func(std::string name){\n    std::cout << \"your name is \" << name << std::endl;\n}\n\n/* a and b are passed by value */\nstatic int add(int a, int b){\n    return a+b; //gives this back to the function caller\n}\n\n\n/* a and b are passed by value (see pointers) this function is quicker because we don't copy variables*/\nstatic int addRef(int &a, int &b) {\n    return a + b; //gives this back to the function caller\n}\n\nint main{\n    func(\"tom\"); //prints your name is tom\n\n    add(4,5); // returns 9\n\n    func(add(5,6)); // prints your name is 11\n}"
  },
  {
    "name": "Function return types",
    "info": "What we can return from functions",
    "content": "void //returns void aka nothing\nint //returns an integer\ndouble //returns a double\nchar //retunrs a characther\nstd::string //returns a string\nclass //returns a class instance\nstruct //returns a struct instance"
  },
  {
    "name": "Inline functions",
    "info": "Inline functions are functions that will be replaced as if it was normal code that never called a function",
    "content":  "#include <iostream>\n#include <string>\n\n//an inline function that when called will be replaced by the body of this function)\ninline void printList(std::string name , std::string address){\n    std::cout << \"your name is: \" << name << std::endl;\n    std::cout << \"your address is: \" << address << std::endl;\n}\n\nint main(){\n    printList(\"tom\",\"antwerp\");\n}\n\n\n//the compiler will read this code and transforms it into:\n\nint main(){\n    std::cout << \"your name is: \" << \"tom\" << std::endl;\n    std::cout << \"your address is: \" << \"antwerp\" << std::endl;\n}\n\n//this is use when you need the extra performance because looking up the address of a fuction takes time\n//note don't make inline functions to big because they will be put in the cpu register\n//if they are to big the inline will have no effect and the compiler will ignore this\n//inline functions also make the .exe bigger if you call the function multiple times.\n\n\n\n"
  },
  {
    "name": "Function pointers",
    "info": "Pointers to the memory address of a function",
    "content": "int add(int a, int b) {\n    return a + b;\n}\n\n/* This is a function that receives 2 functions as a parameter and the parameter to put int the function */\nint multiplySum(int(*funcptr)(int, int), int(*funcptr2)(int, int), int a, int b, int a2, int b2) {\n    return funcptr(a, b) * funcptr2(a2, b2);\n}\n\nint main(){\n        auto funcptr = add; //make the compiler decide the type\n        int(*funcptr)(int a, int b) = add; //full function declaration\n        funcptr(3,5); //returns 8\n\n        multiplySum(funcptr(3,5),funcptr(5,5),3,5,5,5) // returns 80\n}"
  },
  {
    "name": "lambdas",
    "info": "De locatie waar een c/c++ programma start",
    "content": "\n//int y is a Lambda  \n//a lambda is an anonimous function which we can pass into other functions\n//Basicly we can only us it once.\n//first and second are our parametes we pass into the function\n//we also have a body were we can use normal things.\n//the only special part are the [] here we pass global values is because by default we can't use those in lambdas\nint y = [] (int first, int second)  \n{  \n    return first + second;  \n};  \n\n[](){}//this is the smalles posible lambda\n\n[&](){}//you pass all enclosed scope variables by reference\n[&, i](){}//you pass everything by referenc but i by value\n[this](){} //capture the current object\n[=]//capturing all variables by value\n\n//you can also mix these by comma sepparating them"
  },
  {
  "name": "const",
  "info": "How to make functions/variables etc constant",
  "content":  "#include <iostream>\n#include <string>\n\n//by making parameter const we aren't allowed to change the parameter in the function\nvoid printName(const std::string &name){\n        std::cout << name << std::endl;\n}\n\n\n//by making the function const we promise we won't modify anything in the function\nint compute(const int &a, const int &b) const{\n        return a+b;\n}\n\n//by making the return type const the user of this function isn't allowed to change the return value\nconst int computeConstOut(const int &a, const int &b) const{\n        return a+b;\n}\n\nint main(){\n    const float pi = 3.14f; //we can't change this variable the value always stays the same\n    printName(\"tom\"); // tom isn't allowed to be modified\n    compute(10,15); // 10 and 15 aren't allowed to be modified and additional parameters like global variables aren't either\n    const int output = computeConstOut(10,15); // we must mark output to be const because we can't modify the return value\n\n}\n\n\n"
  },

  {
    "name": "typedef",
    "info": "Give a type an nickname",
    "content":    "#include <vector>\n#include <unordered_map>\n\n//usefull for very big variable declarations to give them a short nickname\ntypedef int lol;\n\n//example\n\ntypedef std::vector<std::unordered_map<double>> bigType;\n\n/* Changed int to lol*/\nlol main(){\n        std::vector<std::unordered_map<double>> hello; //same variable type\n        bigType hay; //as this one\n}"
  },
  {
    "name": "preprocessor",
    "info": "Commands that happen before compilation",
    "content": "/* Preprocessor commands are usefull for repeated code\nOr when you need different code for release and debug mode (you don't need to log everything in release this would be mean extra clock cycles*/\n\n/* Preprocessor commands are defined with the # symbol*/\n\n//examples\n\n#include \"relative path\"        //this literally copy pasts the other file in this file only relative to this file\n#include <\"Absolute path\">      //this literally copy pasts the other file in this file only from 1 location on your computer (depends on the compiler)\n#region \"name\"                    //This sets a region of code usefull for minimizing code\n#define Alias Original            //this gives a nickname to your code \n\n\n#ifdef __debug__                //preprocessor if statement if debug is defined than do this code\n#elif __release__                //if release is defined to this code\n#else                            //if nothing is defined do this\n#endif                            //end if statement\n\n#ifndef _debug__                //same as before but if debug is not defined\n#elif __release__\n#else\n#endif\n\n#pragma once //if you use include on the file containing this more than once that pragma will only copy it once \n//usefull if you don't want multiple declarations"
  },
  {
    "name": "Enum",
    "info": "An enumerations of integers",
    "content": "\n//an enum is a group of integers put together\n//usefull for state machines\nenum hello\n{\n    a, //int a =0;\n    b, //b =1\n    c, //c = 2\n    d = 5, //d =5\n    e = 10 //e = 10\n};\n\nint main(){\n    hello hi = hello::a;\n\n    if(hi == hello::b){\n        //does not run\n    }else{\n        //this runs\n    }\n\n    if(hi == 0){\n        //this runs because a is just an integer\n    }\n}"
  },
  {
    "name": "Struct",
    "info": "A struct is a container for multiple variables (used to make lists) by default everything is publicly visable",
    "content": "/* A struct is a class with the defualt variables public (used to have multiple variables as return type of a function*/\n/* structs can have functions inside them and you can call them*/\nstruct hello\n{\npublic:\n    hello() {}\n    hello(int a, int b, float fa, float fb, double e) : a(a), b(b), c(fa), d(fb), e(e)\n    {}\n\n    float getPrivateC() { return c; }\n    int a;\n    int b;\nprivate:\n    float c;\n    float d;\nprotected:\n    double e;\n};\n\n\nint main(){\n        //initialize default struct variables\n        hello hi(1,2,1.0f,2.0f,3.0);\n        //call constructor with no values\n        hello hi2;\n        //we can only assign public variables because main is not a stuct\n        //and we can only read public variables\n        hi2.a = 5;\n        hi2.b = 3;\n        hi2.getPrivateC(); //this will return private variable c because the methode is the struct itself\n}"
  },
  {
    "name": "Class",
    "info": "A class is a container for multiple variables (used to make objects)",
    "content": "/*A class is by default private  */\n/* classes can have functions inside them and you can call them*/\n\nclass hello\n{\n\n/* Everybody with access to the class can access public variables*/\npublic:\n\n    //constructor called when the class is created\n    hello() {}\n    hello(int a, int b, float fa, float fb, double e) : a(a), b(b), c(fa), d(fb), e(e)\n    {}\n\n    //destructor is called when the object is destroyed\n    ~hello(){\n        delete ptr // if a class has heap based variables don't forget to delete them\n    }\n\n    float getPrivateC() { return c; }\n    int a;\n    int b;\n\n/* Only this class can access these variables*/\nprivate:\n    float c;\n    float d;\n    float* ptr;\n\n/* Every instance of this class can access protected variable*/\nprotected:\n    double e;\n};\n\n\nint main(){\n        //initialize default struct variables\n        hello hi(1,2,1.0f,2.0f,3.0);\n        //call constructor with no values\n        hello hi2;\n        //we can only assign public variables because main is not a stuct\n        //and we can only read public variables\n        hi2.a = 5;\n        hi2.b = 3;\n        hi2.getPrivateC(); //this will return private variable c because the methode is the struct itself\n}"
  },
  {
    "name": "Header",
    "info": "Headers are used to include classes in other cpp files",
    "content": "----- Hero.h -----\n#pragma once //only include this file once per translation unit\n\n//we define our class here so that we can use it in many files\nclass hero{\npublic:\n    //default constructors\n    hero();\n    hero(const float &health, const float &damage);\n    hero(const float &x,const float &y,const float &z);\n    hero(const float &health, const float &damage,const float &x,const float &y,const float &z);\n\n    //destructor\n    ~hero();\n\n    //methods\n\n    void teleport(const float &x,const float &y,const float &z);\n    void setDamage(float damage);\n    void setHealth(float health);\n\n    //variables\n    float m_health, m_damage; //attributes of the hero\nprivate:\n    //variables\n    float m_x, m_y, m_z: //location of the hero\n}\n\n\n---Hero.cpp---\n#include \"hero.h\"\n//Hero we define the body of our methods\n\n    //default constructors\n    hero::hero(): m_health(100.0f), m_damage(10.0f), m_x(0.0f), m_y(0.0f), m_z(0.0f) //initializer list\n    {}\n    hero::hero(const float &health, const float &damage): m_health(health), m_damage(damage), m_x(0.0f), m_y(0.0f), m_z(0.0f){\n    }\n    hero::hero(const float &x,const float &y,const float &z): m_health(100.0f), m_damage(10.0f), m_x(x), m_y(y), m_z(z) //initializer list\n    hero::hero(const float &health, const float &damage,const float &x,const float &y,const float &z): m_health(health), m_damage(damage), m_x(x), m_y(y), m_z(z)\n\n    //destructor\n    hero::~hero(){}//we don't need it\n\n    //methods\n\n    void hero::teleport(const float &x,const float &y,const float &z){\n        m_x = x;\n        m_y = y;\n        m_z = z;\n    }\n    void hero::setDamage(float damage){\n        m_damage = damage;\n    }\n    void hero::setHealth(float health){\n        m_health = health;\n    }\n\n\n---main.cpp---\n#include \"hero.h\"\n\nint main(){\n    hero tom(1000.0f,50.0f); //we set the health and damage look at the constructor\n    tom.teleport(10.0f,5234.0f,49.9f); //we teleport tom to the new location\n\n    hero tim = new hero(18.0f,3200.0f,40.9f); //we create tim on the heap and call the constructor that sets the location\n}//end of scope tom is deleted (destructor is called) but tim remains because we didn't call the delete keyword "
  },
  {
    "name": "Friend functions",
    "info": "A function that acts like it is a private member of class",
    "content": "#include <iostream>\n \nusing namespace std;\n \nclass Box {\n   double width;\n   \n   public:\n      friend void printWidth( Box box );\n      void setWidth( double wid );\n};\n\n// Member function definition\nvoid Box::setWidth( double wid ) {\n   width = wid;\n}\n\n// Note: printWidth() is not a member function of any class.\nvoid printWidth( Box box ) {\n   /* Because printWidth() is a friend of Box, it can\n   directly access any member of this class */\n   cout << \"Width of box : \" << box.width <<endl;\n}\n \n// Main function for the program\nint main() {\n   Box box;\n \n   // set box width without member function\n   box.setWidth(10.0);\n   \n   // Use friend function to print the wdith.\n   printWidth( box );\n \n   return 0;\n}\n\n\n"
  },
  {
    "name": "Copy constructor",
    "info": "Constructor used to copy an object",
    "content": "#include <memory> // used for shared_ptr, weak_ptr and unique_ptr\n\nclass entity\n{\npublic:\n    entity();\n    entity(const entity &copy); //copy constructor called when we need to copy a class\n    ~entity();\n\nprivate:\n\n};\n\nentity::entity()\n{\n}\n\nentity::entity(const entity &copy) //perform logic here (like copying variables)\n{\n    std::cout << \"Entity is copied\" << std::endl;\n}\n\nentity::~entity()\n{\n}\n\n\n\nint main(){\n{\n        Entity a1();\n        Entity a2(a1);//we copied entity a1\n        Entity a3 = a2 //if we have an operator overload then this would also be a copy constructor\n}"
  },
  {
    "name": "Threading with mutex",
    "info": "Start multiple threads but lock them using a mutex to avoid multiple thread to use the same resource",
    "content": "#include <string>\n#include <iostream>\n#include <thread>          // c++ 11 threads\n#include <mutex>          // std::mutex\n#define PAUZE std::cin.get()\n\nstd::mutex mtx;           // mutex for critical section\n\nusing namespace std;\n\n// we are locking std::cout up for the thread (deadlocking it) this way other threads need to wait until we unlock it.\n//otherwise we would have multiple threads using a shared resource\nvoid LogThread(std::string msg) {\n        mtx.lock();\n        std::cout << msg << std::endl;\n        mtx.unlock();\n    }\n\n\n\nconst int THREADS = 50;\n\nvoid mutexThread() {\n    std::thread t[THREADS]; //thread array\n\n    for (int i = 0; i < THREADS - 1; i++)\n    {\n        // Constructs the new thread and runs it. Does not block execution.\n        \n        t[i] = std::thread(LogThread, std::string(\"logging on thread: \") + std::to_string(i));\n        \n    }\n\n    LogThread(\"logging on the main thread\");\n\n    for (int i = 0; i < THREADS - 1; i++)\n    {\n        // Constructs the new thread and runs it. Does not block execution.\n        t[i].join();\n    }\n\n}\n\n\nint main()\n{\n    LogThread(\" ---------------------------------------------------- Using threads with mutex  ---------------------------------------------------- \");\n    mutexThread();\n    \n\n    PAUZE;\n    return 0;\n}"
  }
]

