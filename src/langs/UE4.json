[
  {
    "name": "UE4 Default Actor",
    "info": "A default actor",
    "content": "#include \"GameFramework/Actor.h\"\n#include \"MyActor.generated.h\"\n\n\n// Actor.h\n/* Unreal Engine classes always start with a UCLASS preprocessor definition*/\nUCLASS()\nclass AMyActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AMyActor();\n\n    // Called every frame\n    virtual void Tick( float DeltaSeconds ) override;\n\n    /* Set property tobe used anywere including inside the engine*/\n    UPROPERTY(EditAnywhere)\n    int32 TotalDamage;\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n};\n\n//Actor.cpp\n\nAMyActor::AMyActor()\n\n{\n\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you do not need it.\n\n    PrimaryActorTick.bCanEverTick = true;\n\n}"
  },
  {
    "name": "UPROPERTY",
    "info": "A function declaration to be used from within the editor",
    "content":  "/* Default declaration of a Uproperty*/\n\n UPROPERTY([specifier, specifier, ...], [meta=(key=value, key=value, ...)])\n Type VariableName;\n\n //specifiers you can use as a UPROPERTY\n\n /*\n Config //Property should be loaded/saved to ini file as permanent profile.\n\nGlobalConfig //Same as above but load config from base class, not subclass.\n\nLocalized //Property should be loaded as localizable text. Implies ReadOnly.\n\nTransient //Property is transient: shouldn't be saved, zero-filled at load time. Opposite of the SaveGame specifier.\n\nDuplicateTransient //Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)\n\nNonPIETransient //Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)\n\nExport //Object property can be exported with it's owner.\n\nEditInline //Edit this object reference inline in the editor.\n\nNoClear //Hide clear (and browse) button in the editor.\n\nEditFixedSize //Indicates that elements of an array can be modified in Editor, but its size cannot be changed.\n\n//Note Static arrays of containers, such as TArray, are not allowed. Use dynamic arrays.\n\n//Note May not work properly with container arrays of Structs.\n\nReplicated //Property is relevant to network replication.\n\nReplicatedUsing //Property will be configured for replication. The provided function is called only when the replicated property is received via replication.\n\n\nRepRetry //Retry replication of this property if it fails to be fully sent (e.g. object references not yet available to serialize over the network)\n\nNotReplicated //Skip replication (only for struct members and parameters in service request functions).\n\nInterp //Interpolatable property for use with matinee. Always user-settable in the editor.\n\nNonTransactional //Changes to this variable value will not be included in the editor's undo/redo history.\n\nInstanced //Property is a component reference. Implies EditInline and Export.\n\nBlueprintAssignable //MC Delegates only. Property should be exposed for assigning in blueprints.\n\nCategory //Specifies the category of the property within the Editor. Supports sub-categories separated by \"|\".\n\n// Example    UPROPERTY(Category = \"Gun\")\n\n\nAdvancedDisplay //Moves the property into the Advanced dropdown in the Details panel within the Editor.\n\n\nEditAnywhere //Indicates that this property can be edited via property windows, archetypes and instances within the Editor.\n\nEditInstanceOnly //Indicates that this property can be edited by property windows, but only on instances, not on archetypes\n\nEditDefaultsOnly //Indicates that this property can be edited by property windows, but only on archetypes. This operator is incompatible with the Visible* specifiers.\n\nVisibleAnywhere //Indicates that this property is visible in property windows, but cannot be edited at all\n\nVisibleInstanceOnly //Indicates that this property is only visible in property windows for instances, not for archetypes, and cannot be edited\n\nVisibleDefaultsOnly //Indicates that this property is only visible in property windows for archetypes, and cannot be edited\n\nBlueprintReadOnly //This property can be read by blueprints, but not modified.\n\nBlueprintReadWrite //This property can be read or written from a blueprint.\n\nAssetRegistrySearchable //The AssetRegistrySearchable keyword indicates that this property and it's value will be automatically added to the asset registry for any asset class instances containing this as a member variable. It is not legal to use on struct properties or parameters.\n\nSaveGame //Property should be serialized for save game. Opposite of the Transient specifier.\n\nBlueprintCallable //Multicast Delegates only. Property should be exposed for calling in blueprint code\n\nBlueprintAuthorityOnly //MC Delegates only. This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.\n\nTextExportTransient //Property shouldn't be exported to text format (e.g. copy/paste)\n */"
  },
  {
    "name": "UFUNCTION",
    "info": "A function declaration to be used from within the editor",
    "content": "/* Default declaration of a UFUNCTION*/\n\nUFUNCTION([specifier, specifier, ...], [meta(key=value, key=value, ...)])\nReturnType FunctionName([Parameter, Parameter, ...])\n\n//specifiers you can use as a UFUNCTION\n\nBlueprintAuthorityOnly //This function will only execute from Blueprint code if running on a machine with network authority (a server, dedicated server, or single-player game).\n\nBlueprintCallable //The function can be executed in a Blueprint or Level Blueprint graph.\n\nBlueprintCosmetic //This function is cosmetic and will not run on dedicated servers.\n\nBlueprintGetter //This function will be used as the accessor for a Blueprint-exposed property. This specifier implies BlueprintPure and BlueprintCallable.\n\nBlueprintImplementableEvent //The function can be implemented in a Blueprint or Level Blueprint graph.\n\nBlueprintInternalUseOnly //Indicates that the function should not be exposed to the end user.\n\nBlueprintNativeEvent //This function is designed to be overridden by a Blueprint, but also has a default native implementation. Declares an additional function named the same as the main function, but with _Implementation added to the end, which is where code should be written. The autogenerated code will call the \"_Implementation\" method if no Blueprint override is found.\n\nBlueprintPure //The function does not affect the owning object in any way and can be executed in a Blueprint or Level Blueprint graph.\n\nBlueprintSetter //This function will be used as the mutator for a Blueprint-exposed property. This specifier implies BlueprintCallable.\n\nCallInEditor //This function can be called in the editor on selected instances via a button in the details panel.\n\nCategory = TopCategory|SubCategory|Etc //Specifies the category of the function when displayed in Blueprint editing tools. Define nested categories using the | operator.\n\nClient //The function is only executed on the client that owns the Object on which the function is called. Declares an additional function named the same as the main function, but with _Implementation added to the end. The autogenerated code will call the \"_Implementation\" method when necessary.\n\nCustomThunk //the UnrealHeaderTool code generator will not produce a thunk for this function; it is up to the user to provide one.\n\nExec //The function can be executed from the in-game console. Exec commands only function when declared within certain classes.\n\nNetMulticast //The function is both executed locally on the server and replicated to all clients, regardless of the Actor's NetOwner.\n\nReliable //The function is replicated over the network, and is guaranteed to arrive regardless of bandwidth or network errors. Only valid when used in conjunction with Client or Server.\n\nSealedEvent //This function cannot be overridden in subclasses. The SealedEvent keyword can only be used for events. For non-event functions, declare them as static or final to seal them.\n\nServiceRequest //This function is an RPC service request.\n\nServiceResponse //This function is an RPC service response.\n\nServer //The function is only executed on the server. Declares an additional function named the same as the main function, but with _Implementation added to the end, which is where code should be written. The autogenerated code will call the \"_Implementation\" method when necessary.\n\nUnreliable //The function is replicated over the network but can fail due to bandwidth limitations or network errors. Only valid when used in conjunction with Client or Server.\n\nWithValidation //Declares an additional function named the same as the main function, but with _Validation added to the end. This function takes the same parameters, and returns a bool to indicate whether or not the call to the main function should proceed."
  },
  {
    "name": "Unreal variables",
    "info": "How to use UE4 specific variables",
    "content": "//Variables in unreal engine\n\n//ints\n//you also have 8 16 32 and 64 bit integers\nuint32 <name>//32 bit unsigned integer \nint32  <name>//32 bit signed integer\n\n//floats\nfloat  <name>\ndouble <name>\n\n//strings\nFString <name> //like a normal string\nFName <name> //reference to immutable case-insensitive string\nFText <name> //robust version of a string used for translation\n\n//example\n//Use TEXT macro for setting string variable literals\nMyActorPtr->ActorName = FString(TEXT(\"Super Samson The Second\"));\n\n\n//Unreal Arrays\nTArray<Datatype> <name>;\n\n//Example\nTArray<int32> intArray;\n\n//Add an item\nTArray<FString> StrArr;\nStrArr.Add(TEXT(\"Hello\")); //copy the item\nStrArr.Emplace(TEXT(\"World\")); //a reference to the item\nStrArr.AddUnique(TEXT(\"!\")); //only add it if the type doesn't exist\n\n//Looping \n\nfor (int32 Index = 0; Index != StrArr.Num(); ++Index)\n{\n    JoinedStr += StrArr[Index];\n    JoinedStr += TEXT(\" \");\n}\n\n//Usefull functions\nbool bValidM1 = StrArr.IsValidIndex(-1); //prevent buffer overflow\nuint32 ElementSize = StrArr.GetTypeSize(); //equal to sizeof(<dataType>)\nint32 Count = StrArr.Num(); //size of the array\nbool bContains = StrArr.Contains(TEXT(\"Goodbye\")); //If the array containt a value\nStrArr.Pop(); // remove final element\nStrArr.Remove(TEXT(\"hello\")); // remove an element\nStrArr.RemoveAt(2); // Removes the element at index 2\n\n\n//FVector (struct)\nFVector example(0.0f,1.0f,0.5f); //set the x y and z values\nexample.z = 5.0f; //set a value"
  },
  {
    "name": "Structs and Enums",
    "info": "How to use structs nd enums with UE4",
    "content": "//Default Struct example\n\n//If you want this to appear in BP, make sure to use this instead\n//USTRUCT(BlueprintType)\nUSTRUCT()\nstruct FJoyStruct\n{\n    GENERATED_BODY()\n \n    //Always make USTRUCT variables into UPROPERTY()\n    //    any non-UPROPERTY() struct vars are not replicated\n \n    // So to simplify your life for later debugging, always use UPROPERTY()\n    UPROPERTY()\n    int32 SampleInt32;\n \n        //If you want the property to appear in BP, make sure to use this instead\n        //UPROPERTY(BlueprintReadOnly)\n    UPROPERTY()\n    AActor* TargetActor;\n \n    //Set\n    void SetInt(const int32 NewValue)\n    {\n        SampleInt32 = NewValue;\n    }\n \n    //Get\n    AActor* GetActor()\n    {\n        return TargetActor;\n    }\n \n    //Check\n    bool ActorIsValid() const\n    {\n        if(!TargetActor) return false;\n        return TargetActor->IsValidLowLevel();\n    }\n \n    //Constructor\n    FJoyStruct()\n    {\n        //Always initialize your USTRUCT variables!\n        //   exception is if you know the variable type has its own default constructor\n        SampleInt32     = 5;\n        TargetActor = NULL;\n    }\n};\n\n\n//Enums\n\n//Header\nUENUM(BlueprintType)        //\"BlueprintType\" is essential to include\nenum class EVictoryEnum : uint8\n{\n        VE_Dance     UMETA(DisplayName=\"Dance\"),\n        VE_Rain     UMETA(DisplayName=\"Rain\"),\n        VE_Song        UMETA(DisplayName=\"Song\")\n};\n \nUCLASS()\nclass YourClass : public YourSuperClass\n{\n    GENERATED_UCLASS_BODY()\n \n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Enum)\n    EVictoryEnum VictoryEnum;\n \n    //Rest of Class Code\n};\n\n//CPP\nif(VictoryEnum == EVictoryEnum::VE_Dance)\n{\n    VictoryEnum = EVictoryEnum::VE_Song;\n}\nelse\n{\n    VictoryEnum = EVictoryEnum::VE_Rain;\n}"
  },
  {
    "name": "Debugging",
    "info": "Some usefull things you can do to debug UE4 code",
    "content": "//Debugging\n\nif(GEngine)\n      GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(\"Some debug message!\"));\n\n//In your gamemode class\npublic:\n \n    /*Function with no parameters but can be called in the console*/\n    UFUNCTION(Exec, Category = ExecFunctions)\n    void DoSomething();\n\n//Printing in the log files\nUE_LOG(LogTemp, Warning, TEXT(\"Your message\"));\n//Fatal            Fatal level logs are always printed to console and log files and crashes even if logging is disabled.\n//Error            Error level logs are printed to console and log files. These appear red by default.\n//Warning        Warning level logs are printed to console and log files. These appear yellow by default.\n//Display        Display level logs are printed to console and log files.\n//Log            Log level logs are printed to log files but not to the in-game console. They can still be viewed in editor as they appear via the Output Log window.\n//Verbose        Verbose level logs are printed to log files but not the in-game console. This is usually used for detailed logging and debugging.\n//VeryVerbose    VeryVerbose level logs are printed to log files but not the in-game console. This is usually used for very detailed logging that would otherwise spam output.\n\n//Assertions\ncheckNoEntry(); // use this for codepaths that should never execute\n\n//Run console commands via c++\n\nGetWorld()->Exec(GetWorld(), TEXT(\"MyAwesomeConsoleCommand X Y Z\"));"
  },
  {
    "name": "Unreal Config",
    "info": "How to read from the game config file",
    "content": "//Your data is not configured at the location of the default configurations\n//But instead at YourGame\\Saved\\Config\\OS\n\n\n//Reading config\n//in your player controller class\nvoid AController::ConfigGetTests()\n{\n    //Basic Syntax\n    /*\n    bool GetString( \n        const TCHAR* Section, \n        const TCHAR* Key, \n        FString& Value, \n        const FString& Filename \n    );\n    */\n \n    if(!GConfig) return;\n    //~~\n \n    //Retrieve Default Game Type\n    FString ValueReceived;\n    GConfig->GetString(\n        TEXT(\"/Script/Engine.WorldInfo\"),\n        TEXT(\"GlobalDefaultGameType\"),\n        ValueReceived,\n        GGameIni\n    );\n \n    ClientMessage(\"GlobalDefaultGameType\");\n    ClientMessage(ValueReceived);\n \n        //Retrieve Max Objects not considered by GC\n    int32 IntValueReceived = 0;\n    GConfig->GetInt(\n        TEXT(\"Core.System\"),\n        TEXT(\"MaxObjectsNotConsideredByGC\"),\n        IntValueReceived,\n        GEngineIni\n    );\n \n    ClientMessage(\"MaxObjectsNotConsideredByGC\");\n    ClientMessage(FString::FromInt(IntValueReceived));\n \n         //Retrieve Near Clip Plane (how close things can get to camera)\n    float floatValueReceived = 0;\n    GConfig->GetFloat(\n        TEXT(\"/Script/Engine.Engine\"),\n        TEXT(\"NearClipPlane\"),\n        floatValueReceived,\n        GEngineIni\n    );\n \n    ClientMessage(\"NearClipPlane\");\n    ClientMessage(FString::SanitizeFloat(floatValueReceived));\n}\n\n\n\n//Writing to a config\n//write to existing Game.ini\n//the results get stored in YourGameDirSaved Config Windows\nvoid AController::ConfigSetTests()\n{\n    if(!GConfig) return;\n    //~~\n \n    //New Section to Add\n    FString VictorySection = \"Victory.Core\";\n \n    //String\n    GConfig->SetString (\n        *VictorySection,\n        TEXT(\"RootDir\"),\n        TEXT(\"E:\\UE4\\IsAwesome\"),\n        GGameIni\n    );\n \n    //FColor\n    GConfig->SetColor (\n        *VictorySection,\n        TEXT(\"Red\"),\n        FColor(255,0,0,255),\n        GGameIni\n    );\n \n    //FVector\n    GConfig->SetVector (\n        *VictorySection,\n        TEXT(\"PlayerStartLocation\"),\n        FVector(0,0,512),\n        GGameIni\n    );\n \n    //FRotator\n    GConfig->SetRotator (\n        *VictorySection,\n        TEXT(\"SunRotation\"),\n        FRotator(-90,0,0),\n        GGameIni\n    );\n \n    //ConfigCacheIni.h\n    //void Flush( bool Read, const FString& Filename=TEXT(\"\") );\n    GConfig->Flush(false,GGameIni);\n}\n\n\n//IMPORTANT USE\nGConfig->Flush(false,GGameIni);\n//Sometimes the config won't save the changes this guarentees it"
  },
  {
    "name": "Unreal saved files",
    "info": "How to use the .sav file",
    "content": "//create a savegame object from within the editor\n//Function declared in Kismet/GameplayStatics.h\n\n\n// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.\n//Declare the variables you wish to save in the header\n#pragma once\n\n#include \"GameFramework/SaveGame.h\"\n#include \"MySaveGame.generated.h\"\n\n/* Include the headers to be able to create save and load your object*/\n#include \"MySaveGame.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n\n\nUCLASS()\nclass [PROJECTNAME]_API UMySaveGame : public USaveGame\n{\n    GENERATED_BODY()\n\n    public:\n    /* Note that for a savefile to work we need\n    PlayerName SaveSlotName and UserIndex\n    These variables are used to find the correct sav file*/\n    UPROPERTY(VisibleAnywhere, Category = Basic)\n    FString PlayerName; //this will be saved\n\n    UPROPERTY(VisibleAnywhere, Category = Basic)\n    FString SaveSlotName; //This will also be saved\n\n    UPROPERTY(VisibleAnywhere, Category = Basic)\n    uint32 UserIndex; //This too\n\n    UPROPERTY(VisibleAnywhere, Category = Character)\n    uint32 Level; //This is your custom datat to save\n\n    UMySaveGame();\n};\n\n\n//CPP\n// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.\n\n#include \"[ProjectName].h\"\n#include \"MySaveGame.h\"\n\nUMySaveGame::UMySaveGame()\n{\n    SaveSlotName = TEXT(\"TestSaveSlot\");\n    UserIndex = 0;\n}\n\n\n//Saving a variable\nPlayerName = TEXT(\"PlayerOne\");\nUMySaveGame* SaveGameInstance = Cast<UMySaveGame>(UGameplayStatics::CreateSaveGameObject(UMySaveGame::StaticClass()));\nSaveGameInstance->PlayerName = MyPlayerName;\nUGameplayStatics::SaveGameToSlot(SaveGameInstance, SaveGameInstance->SaveSlotName, SaveGameInstance->UserIndex);\n\n//Getting a variable\nUMySaveGame* LoadGameInstance = Cast<UMySaveGame>(UGameplayStatics::CreateSaveGameObject(UMySaveGame::StaticClass()));\nLoadGameInstance = Cast<UMySaveGame>(UGameplayStatics::LoadGameFromSlot(LoadGameInstance->SaveSlotName, LoadGameInstance->UserIndex));\nFString PlayerNameToDisplay = LoadGameInstance->PlayerName;\nif (GEngine)\n    GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Yellow, PlayerNameToDisplay);"
  },
  {
    "name": "Get All actors of class",
    "info": "Usefull when you need to manipulate a set of objects",
    "content": "//To be able to get all actors or all actors of a class you need to include this\n#include \"EngineUtils.h\"\n\n//Object iterator\nfor ( TObjectIterator<USkeletalMeshComponent> Itr; Itr; ++Itr )\n{\n    // Access the subclass instance with the * or -> operators.\n    USkeletalMeshComponent *Component = *Itr;\n    ClientMessage(Itr->GetName());\n}\n\n//Actor Iterator\nfor (TActorIterator<AStaticMeshActor> ActorItr(GetWorld()); ActorItr; ++ActorItr)\n{\n    // Same as with the Object Iterator, access the subclass instance with the * or -> operators.\n    AStaticMeshActor *Mesh = *ActorItr;\n    ClientMessage(ActorItr->GetName());\n    ClientMessage(ActorItr->GetActorLocation().ToString());\n}\n\n/*\nObject iterator vs Actor Iterator\nBecause AActor extends UObject, the Object Iterator can search for AActors while the Actor Iterator cannot search for instances of UObjects that do not extend AActor at some point.\nThus the Object Iterator can search for all UStaticMeshComponents as well as all ACharacters:\n*/\n\nTObjectIterator<UStaticMeshComponent> Itr; //Use this to get all StaticMeshComponents\nTObjectIterator<ACharacter> Itr; //Use this to get All ACharacter\n\n//Try to us Actor Iterator as much as you can\n\nUWorld* YourGameWorld = nullptr; // Set this somehow from another UObject or pass it in as an argument or parameter\n //This is used when there are Objects not in your gameworld\n\nfor (TObjectIterator<UYourObject> Itr; Itr; ++Itr)\n{\n    // Filter out objects not contained in the target world.\n    if (Itr->GetWorld() != YourGameWorld)\n    {\n       continue;\n    }\n    // Do stuff\n}"
  },
  {
    "name": "UGameMode",
    "info": "The current Gamemode being played",
    "content": "//Mostly cutome code\n//Look at the docs for all functions\n\n//Header\n#pragma once\n \n//Input\n#include \"InputCoreTypes.h\"\n \n#include \"YourPlayerController.generated.h\"\n \nUCLASS(config=Game)\nclass AYourPlayerController : public APlayerController\n{\n    GENERATED_BODY()\npublic:\n    AYourPlayerController(const FObjectInitializer& ObjectInitializer);\n    //Add more functions that affect gameplay\n};\n\n//cpp\n#include \"YourGame.h\"\nAYourPlayerController::AYourPlayerController(const FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n \n}\n//add all those functions"
  },
  {
    "name": "UGameInstance",
    "info": "The instance the current player is seeing (persistant since game launch)",
    "content": "//Header\n\n#pragma once\n \n//Essential Include\n#include \"Engine/GameInstance.h\" \n \n#include \"SolusGameInstance.generated.h\"\n \nUCLASS()\nclass USolusGameInstance : public UGameInstance\n{\n    GENERATED_BODY()\npublic:\n     USolusGameInstance(const FObjectInitializer& ObjectInitializer);\n \n    /** Increment this value in any map, change map, and notice it persists! */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=SolusHUDCrosshair)\n    int32 InterLevelPersistentValue; \n \n};\n\n\n//cpp\n#include \"Solus.h\"\n#include \"SolusGameInstance.h\"\n \nUSolusGameInstance::USolusGameInstance(const FObjectInitializer& ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n \n}\n\n\n//PlayerController could be anywhere with access to the game instance\nvoid ASolusPC::PlayerTick(float DeltaTime)\n{\n    Super::PlayerTick(DeltaTime);\n \n    USolusGameInstance* SGI = Cast<USolusGameInstance>(GetGameInstance());\n    if(SGI)\n    { \n        SGI->InterLevelPersistentValue++;\n        ClientMessage(FString::FromInt(SGI->InterLevelPersistentValue));\n    }\n \n}"
  },
  {
    "name": "UActor",
    "info": "How to define actors (Visable objects)",
    "content": "//AActor\n\n//Header\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Test.generated.h\"\n\nUCLASS()\nclass BALLER_API ATest : public AActor\n{\n    GENERATED_BODY()\npublic:\n    /** point light component */\n    UPROPERTY(VisibleAnywhere, Category = \"Switch Components\")\n        class UPointLightComponent* PointLight1;\n\n    /** sphere component */\n    UPROPERTY(VisibleAnywhere, Category = \"Switch Components\")\n        class USphereComponent* Sphere1;\n\n    /** StaticMesh used for the object can be edited in engine */\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Ball, meta = (AllowPrivateAccess = \"true\"))\n        class UStaticMeshComponent* Ball;\n\n    UPROPERTY(VisibleAnywhere, Category = \"Switch Components\")\n        float Oscilator;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Oscillation\")\n        float OscilatorIntensity;\n\n    ATest();\n\n    /** called when something enters the sphere component */\n    UFUNCTION()\n        void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);\n\n    /** called when something leaves the sphere component */\n    UFUNCTION()\n        void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);\n\n    /** Toggles the light component's visibility*/\n    UFUNCTION()\n        void ToggleLight();\n\n    /** the desired intensity for the light */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Oscillation\")\n        float DesiredIntensity;\n\n    /** the minimal desired intensity for the light */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Oscillation\")\n        float LighOffset;\n\n    /*Event called when the actor first gets launched*/\n    virtual void BeginPlay();\n    /*Called every fram with the frame time*/\n    virtual void Tick(float DeltaTime);\n};\n\n\n\n//CPP\n\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"Test.h\" //Always include own header first\n\n//UE4 uses forward slahes not backward ones\n#include \"UObject/ConstructorHelpers.h\"\n#include \"Engine/CollisionProfile.h\"\n#include \"Classes/Components/PointLightComponent.h\" //we include our components individual for fast compile times\n#include \"Classes/Components/SphereComponent.h\"     //Serach the UE4 api to see which header you need or find it int the engine solution\n#include \"Components/StaticMeshComponent.h\"\n//You could also include everything but that would take a long time to compile\n//#include \"Engine.h\"\n\n\n\n// Sets default values\nATest::ATest()\n{\n     // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    static ConstructorHelpers::FObjectFinder<UStaticMesh> BallMesh(TEXT(\"/Game/Rolling/Meshes/BallMesh.BallMesh\")); // get the static mesh\n\n    DesiredIntensity = 5000000.0f;\n    LighOffset = 500000.0f;\n\n    PointLight1 = CreateDefaultSubobject<UPointLightComponent>(TEXT(\"PointLight1\"));\n    PointLight1->Intensity;\n    PointLight1->Intensity = DesiredIntensity;\n    PointLight1->bVisible = true;\n    RootComponent = PointLight1;\n\n\n    Sphere1 = CreateDefaultSubobject<USphereComponent>(TEXT(\"Sphere1\"));\n    Sphere1->InitSphereRadius(500.0f);\n    Sphere1->SetupAttachment(RootComponent);\n\n    Sphere1->OnComponentBeginOverlap.AddDynamic(this, &ATest::OnOverlapBegin);       // set up a notification for when this component overlaps something\n    Sphere1->OnComponentEndOverlap.AddDynamic(this, &ATest::OnOverlapEnd);       // set up a notification for when this component overlaps something\n\n                                                                                 // Create mesh component for the ball\n    Ball = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Ball0\"));\n    Ball->SetStaticMesh(BallMesh.Object);\n    Ball->SetRelativeLocation(FVector(50.0f, 50.0f, 200.0f)); //move the ball away from the rootcomponent\n    Ball->SetupAttachment(RootComponent);\n\n    Oscilator = 0;\n    OscilatorIntensity = 0.7f;\n}\n\n\nvoid ATest::OnOverlapBegin(UPrimitiveComponent * OverlappedComp, AActor * OtherActor, UPrimitiveComponent * OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult)\n{\n    if (OtherActor && (OtherActor != this) && OtherComp)\n    {\n        ToggleLight();\n        if (GEngine)\n            GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(\"Toggling\"));\n    }\n}\n\nvoid ATest::OnOverlapEnd(UPrimitiveComponent * OverlappedComp, AActor * OtherActor, UPrimitiveComponent * OtherComp, int32 OtherBodyIndex)\n{\n    if (OtherActor && (OtherActor != this) && OtherComp)\n    {\n        ToggleLight();\n        if (GEngine)\n            GEngine->AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT(\"Toggling\"));\n\n    }\n}\n\nvoid ATest::ToggleLight()\n{\n    PointLight1->ToggleVisibility();\n}\n\n// Called when the game starts or when spawned\nvoid ATest::BeginPlay()\n{\n    Super::BeginPlay();\n    \n}\n\n// Called every frame\nvoid ATest::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    Oscilator += DeltaTime;\n    //using a sin to change the light intensity and make negative values positive\n    PointLight1->SetIntensity((DesiredIntensity / 2) * (FMath::Sin(Oscilator / OscilatorIntensity)) + LighOffset + (DesiredIntensity / 2));\n}"
  },
  {
    "name": "PlayerPawn",
    "info": "How to define the playable character",
    "content": "//Player Pawn aka the controllable player\n\n//Header\n// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"<name>.generated.h\"\n\nUCLASS()\nclass Source_APU <name> : public APawn\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this pawn's properties\n    <name>();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick( float DeltaSeconds ) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n\nprotected:\n    UPROPERTY(EditAnywhere)\n    USpringArmComponent* OurCameraSpringArm;\n    UCameraComponent* OurCamera;\n\n    //Input variables\n    FVector2D MovementInput;\n    FVector2D CameraInput;\n    float ZoomFactor;\n    bool bZoomingIn;\n\n    //Input functions\n    void MoveForward(float AxisValue);\n    void MoveRight(float AxisValue);\n    void PitchCamera(float AxisValue);\n    void YawCamera(float AxisValue);\n    void ZoomIn();\n    void ZoomOut();\n};\n\n\n\n\n\n//<name>.cpp\n// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.\n\n#include \"HowTo_PlayerCamera.h\"\n#include \"<name>.h\"\n\n// Sets default values\n<name>::<name>()\n{\n    // Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    //Create our components\n    RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"RootComponent\"));\n    OurCameraSpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraSpringArm\"));\n    OurCameraSpringArm->SetupAttachment(RootComponent);\n    OurCameraSpringArm->SetRelativeLocationAndRotation(FVector(0.0f, 0.0f, 50.0f), FRotator(-60.0f, 0.0f, 0.0f));\n    OurCameraSpringArm->TargetArmLength = 400.f;\n    OurCameraSpringArm->bEnableCameraLag = true;\n    OurCameraSpringArm->CameraLagSpeed = 3.0f;\n    OurCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"GameCamera\"));\n    OurCamera->SetupAttachment(OurCameraSpringArm, USpringArmComponent::SocketName);\n\n    //Take control of the default Player\n    AutoPossessPlayer = EAutoReceiveInput::Player0;\n}\n\n// Called when the game starts or when spawned\nvoid <name>::BeginPlay()\n{\n    Super::BeginPlay();\n\n}\n\n// Called every frame\nvoid <name>::Tick( float DeltaTime )\n{\n    Super::Tick(DeltaTime);\n\n    //Zoom in if ZoomIn button is down, zoom back out if it's not\n    {\n        if (bZoomingIn)\n        {\n            ZoomFactor += DeltaTime / 0.5f;         //Zoom in over half a second\n        }\n        else\n        {\n            ZoomFactor -= DeltaTime / 0.25f;        //Zoom out over a quarter of a second\n        }\n        ZoomFactor = FMath::Clamp<float>(ZoomFactor, 0.0f, 1.0f);\n        //Blend our camera's FOV and our SpringArm's length based on ZoomFactor\n        OurCamera->FieldOfView = FMath::Lerp<float>(90.0f, 60.0f, ZoomFactor);\n        OurCameraSpringArm->TargetArmLength = FMath::Lerp<float>(400.0f, 300.0f, ZoomFactor);\n    }\n\n    //Rotate our actor's yaw, which will turn our camera because we're attached to it\n    {\n        FRotator NewRotation = GetActorRotation();\n        NewRotation.Yaw += CameraInput.X;\n        SetActorRotation(NewRotation);\n    }\n\n    //Rotate our camera's pitch, but limit it so we're always looking downward\n    {\n        FRotator NewRotation = OurCameraSpringArm->GetComponentRotation();\n        NewRotation.Pitch = FMath::Clamp(NewRotation.Pitch + CameraInput.Y, -80.0f, -15.0f);\n        OurCameraSpringArm->SetWorldRotation(NewRotation);\n    }\n\n    //Handle movement based on our \"MoveX\" and \"MoveY\" axes\n    {\n        if (!MovementInput.IsZero())\n        {\n            //Scale our movement input axis values by 100 units per second\n            MovementInput = MovementInput.SafeNormal() * 100.0f;\n            FVector NewLocation = GetActorLocation();\n            NewLocation += GetActorForwardVector() * MovementInput.X * DeltaTime;\n            NewLocation += GetActorRightVector() * MovementInput.Y * DeltaTime;\n            SetActorLocation(NewLocation);\n        }\n    }\n}\n\n// Called to bind functionality to input\nvoid <name>::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\n    Super::SetupPlayerInputComponent(InputComponent);\n\n    //Hook up events for \"ZoomIn\"\n    InputComponent->BindAction(\"ZoomIn\", IE_Pressed, this, &<name>::ZoomIn);\n    InputComponent->BindAction(\"ZoomIn\", IE_Released, this, &<name>::ZoomOut);\n\n    //Hook up every-frame handling for our four axes\n    InputComponent->BindAxis(\"MoveForward\", this, &<name>::MoveForward);\n    InputComponent->BindAxis(\"MoveRight\", this, &<name>::MoveRight);\n    InputComponent->BindAxis(\"CameraPitch\", this, &<name>::PitchCamera);\n    InputComponent->BindAxis(\"CameraYaw\", this, &<name>::YawCamera);\n}\n\n//Input functions\nvoid <name>::MoveForward(float AxisValue)\n{\n    MovementInput.X = FMath::Clamp<float>(AxisValue, -1.0f, 1.0f);\n}\n\nvoid <name>::MoveRight(float AxisValue)\n{\n    MovementInput.Y = FMath::Clamp<float>(AxisValue, -1.0f, 1.0f);\n}\n\nvoid <name>::PitchCamera(float AxisValue)\n{\n    CameraInput.Y = AxisValue;\n}\n\nvoid <name>::YawCamera(float AxisValue)\n{\n    CameraInput.X = AxisValue;\n}\n\nvoid <name>::ZoomIn()\n{\n    bZoomingIn = true;\n}\n\nvoid <name>::ZoomOut()\n{\n    bZoomingIn = false;\n}"
  },
  {
    "name": "Spawning actor",
    "info": "How to spawn a new actor",
    "content": "//Spawning a UActor\n#include \"actor.h\"\n\n AMyActorSubClass* MyActor= GetWorld()->SpawnActor<AMyActorSubClass>(AMyActorSubClass::StaticClass());\n\n\n //Example code\n void AMySpawner::Tick(float DeltaTime)  \n{  \n    Super::Tick(DeltaTime); // Call parent class tick function  \n\n    if (Iteration > 0)  \n    {  \n        TimeToSpawn -= DeltaTime;  \n        if (TimeToSpawn < 0.f)  \n        {  \n            // Make a location for the new actor to spawn at (300 units above this actor)  \n            FVector NewLocation = GetActorLocation() + FVector(0.f, 0.f, 300.f);  \n\n            // Spawn the new actor (Using GetClass() instead of AMySpawner so that if someone derives a new class  \n            // from AMySpawner we spawn an instance of that class instead)  \n            AMySpawner* NewActor = GetWorld()->SpawnActor<AMySpawner>(GetClass(), NewLocation, FRotator::ZeroRotator);  \n\n            // Housekeeping so that we dont spawn new actors forever  \n            NewActor->Iteration = Iteration - 1;  \n            Iteration = 0; // stop ourselves spawning any more  \n        }  \n    }  \n\n}"
  },
  {
    "name": "Replication",
    "info": "How to use networking with objects in order to make a multiplayer game",
    "content": "//Header\n#pragma once\n#include \"Core.h\"\n#include \"ReplicatedActor.generated.h\"\n \nUCLASS()\nclass AReplicatedActor : public AActor\n{\n    GENERATED_UCLASS_BODY()\n \npublic:\n \n// NOTE: all functions can have arguments, they will be replicated automatically over the network.\n// NOTE: UObject based classes (or derivatives) should be passed by pointer (*) and will correctly\n// address the version of that object on the receiving client or server (unless that object is not\n// replicated, in which case the pointer will be NULL).\n \n    UFUNCTION(Server, Reliable, WithValidation)\n    void Server_ReliableFunctionCallThatRunsOnServer();\n \n    UFUNCTION(Client, Reliable)\n    void Client_ReliableFunctionCallThatRunsOnOwningClientOnly();\n \n    UFUNCTION(NetMulticast, Unreliable)\n    void Client_UnreliableFunctionCallThatRunsOnAllClients();\n};\n\n//cpp\n#include \"ReplicatedActor.h\"\n#include \"UnrealNetwork.h\"\nAReplicatedActor::AReplicatedActor(const class FPostConstructInitializeProperties& PCIP)\n: Super(PCIP)\n{\n    bReplicates = true;\n}\n \nvoid AReplicatedActor::Server_ReliableFunctionCallThatRunsOnServer_Implementation()\n{\n    // Do something here that modifies game state.\n}\n \nbool AReplicatedActor::Server_ReliableFunctionCallThatRunsOnServer_Validate()\n{\n   // Optionally validate the request and return false if the function should not be run.\n   return true;\n}\n \nvoid AReplicatedActor::Client_ReliableFunctionCallThatRunsOnOwningClientOnly()\n{\n   // Do something here to affect the client. This method was called by the server ONLY.\n}\n \nvoid AReplicatedActor::Client_UnreliableFunctionCallThatRunsOnAllClients_Implementation()\n{\n   // Do something here to affect the client. This method was called by the server ONLY.\n}\n\n//For actor classes you need to implement this code\nvoid AActor::GetLifetimeReplicatedProps( TArray< FLifetimeProperty > & OutLifetimeProps ) const\n{\n    DOREPLIFETIME( AActor, Owner );\n}\n\n//Basic variable repliction\nclass ENGINE_API AActor : public UObject\n{\n    UPROPERTY( replicated )\n    AActor * Owner;\n};"
  },
  {
    "name": "HUD's",
    "info": "How to make a Heads-Up-Display",
    "content": "//Header\n\n// Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.\n  \n#pragma once\n \n#include \"JoyHUD.generated.h\"\n \nUSTRUCT()\nstruct FJoyButtonStruct\n{\n    GENERATED_USTRUCT_BODY()\n \n    //Vars\n    int32         type;\n    FString    toolTip;\n    float         minX;\n    float         maxX;\n    float         minY;\n    float         maxY;\n \n    //~\n \n    //default properties\n \n    FJoyButtonStruct()\n    {\n        type             = -1;\n        toolTip         = \"\";\n        minX             = 0;\n        maxX             = 0;\n        minY             = 0;\n        maxY             = 0;\n    }\n};\n \nUCLASS()\nclass AJoyHUD : public AHUD\n{\n    GENERATED_UCLASS_BODY()\n \n    // Font \n    //I recommend creating the font at a high resolution / size like 36\n    //then you can scale down the font as needed to any size of your choice\n \n    /** Verdana */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=JoyHUD)\n    UFont* VerdanaFont;\n \n    /** Put Roboto Here */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=JoyHUD)\n    UFont* UE4Font;\n \n    /** Font Scaling Used By Your HUD Code */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=JoyHUD)\n    float DefaultFontScale;\n \n    /** HUD Scaling */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=JoyHUD)\n    float GlobalHUDMult;\n \n    // T2D \n    /** Cursor */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=T2D)\n    UTexture2D* CursorMain;\n \n    /** Hovering */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=T2D)\n    UTexture2D* CursorHoveringButton;\n \n    /** Button */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=T2D)\n    UTexture2D* ButtonBackground;\n \n    // Materials \n    /** Events */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Materials)\n    UMaterialInterface* MaterialBackground;\n \n    //\n \n    /* Draw Hud? */\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Options)\n    bool DontDrawHUD;\n \n//Cursor\npublic:\n    FVector2D MouseLocation;\n    void DrawHUD_DrawCursor();\n \n//Buttons\npublic:\n    TArray<FJoyButtonStruct> ButtonsMain;\n    TArray<FJoyButtonStruct> ButtonsConfirm;\n \n    //Cursor In buttons\n    void DrawHUD_CheckCursorInButtons();\n    void CheckCursorInButtonsMain();\n    void CheckCursorInButtonsConfirm();\n \n    const FJoyButtonStruct* CurCheckButton;\n    int32 CheckCursorInButton(const TArray<FJoyButtonStruct>& ButtonArray);\n    int32 ClickedButtonType;\n    //States\n    bool ConfirmDialogOpen;\n    bool InMainMenu;\n \n    int32         ActiveButton_Type;\n    FString     ActiveButton_Tip;\n    bool CursorHoveringInButton;\n//Colors\npublic:\n    const FLinearColor * ColorPtr; \n \n    //Colors\n    static const FColor        FColorBlack;\n    static const FColor        FColorRed;\n    static const FColor        FColorYellow;\n    static const FColor        FColorBlue;\n    static const FColor        FColor_White;\n \n    static const FLinearColor LC_Black;\n    static const FLinearColor LC_Pink;\n    static const FLinearColor LC_Red;\n    static const FLinearColor LC_Yellow;\n//FString\npublic:\n \n    //`Titles\n    static const FString S_Title_Main;\n    static const FString S_Title_Confirm;\n    //`Button Text\n    static const FString S_Button_Restart; \n    static const FString S_Button_Exit;\n \n// Utility \n \n//Stop Camera From Moving With Mouse\nFORCEINLINE void SetCursorMoveOnly(bool CursorOnly)\n{\n    if(!ThePC) return;\n    //\n    ThePC->SetIgnoreLookInput(CursorOnly);\n \n}\n \n//DrawLine\nFORCEINLINE void DrawJoyLine\n(\n    const FVector2D& Start, \n    const FVector2D& End, \n    const FLinearColor& TheColor, \n    const float& Thick\n)\n{\n    if (!Canvas) return;\n    //\n \n    FCanvasLineItem NewLine(Start,End);\n    NewLine.SetColor(TheColor);\n    NewLine.LineThickness = Thick;\n    Canvas->DrawItem(NewLine);\n}    \n \n//~\n \nFORCEINLINE void DrawJoyRect( \n    float X, float Y, \n    float Width, float Height, \n    const FLinearColor& Color\n)\n{\n    if(!Canvas) return;\n    //\n \n    FCanvasTileItem RectItem( \n        FVector2D(X, Y), \n        FVector2D( Width, Height ), \n        Color \n    );\n \n    RectItem.BlendMode = SE_BLEND_Translucent;\n    Canvas->DrawItem(RectItem);\n}\n \n//~\n \n//DrawText\nFORCEINLINE void DrawJoyText(\n    UFont*    TheFont,\n    const FString& TheStr, \n    const float& X, const float& Y, \n    const FLinearColor& TheColor, \n    const float& TheScale,\n    bool DrawOutline=false,\n    const FLinearColor OutlineColor=FLinearColor(0,0,0,1)\n) {\n    if(!Canvas) return;\n    //\n \n    //Text and Font\n    FCanvasTextItem NewText(\n        FVector2D(X,Y),\n        FText::FromString(TheStr),\n        TheFont,\n        TheColor\n    );\n \n    //Text Scale\n    NewText.Scale.Set(TheScale,TheScale);\n \n    //Outline gets its alpha from the main color\n    NewText.bOutlined = true;\n    NewText.OutlineColor = OutlineColor;\n    NewText.OutlineColor.A = TheColor.A * 2;\n \n    //Draw\n    Canvas->DrawItem(NewText);\n}\n \n//~\n//Draw Full Size Tile\nFORCEINLINE void DrawFullSizeTile(UTexture2D* tex, float x, float y, const FColor& Color)\n{\n    if (!Canvas) return;\n    if (!tex) return;\n    //~~\n \n    Canvas->SetDrawColor(Color);\n \n    //Draw\n    Canvas->DrawTile(\n        tex, x, y, 0, //z pos\n        tex->GetSurfaceWidth(), //screen width\n        tex->GetSurfaceHeight(),  //screen height\n        0, //texture start width\n        0, //texture start height\n        tex->GetSurfaceWidth(), //texture width from start\n        tex->GetSurfaceHeight(), //texture height from start\n        BLEND_Translucent\n    );\n}\n \n//~\n \nFORCEINLINE void VDrawTile(UTexture2D* tex, float x, float y, float screenX, float screenY, const FColor& TheColor)\n{\n    if (!Canvas) return;\n    if (!tex) return;\n    //~\n \n    Canvas->SetDrawColor(TheColor);\n \n    //Draw\n    Canvas->DrawTile(\n        tex, x, y, 0, //z pos\n        screenX, //screen width\n        screenY,  //screen height\n        0, //texture start width\n        0, //texture start height\n        tex->GetSurfaceWidth(), //texture width from start\n        tex->GetSurfaceHeight(), //texture height from start\n        BLEND_Translucent\n    );\n}\n \n//~\n \n//Draw\npublic:\n    void DrawHUD_DrawDialogs();\n \n    //Menus\n    void DrawMainMenu();\n    void DrawConfirm();\n \n    //Buttons\n    void DrawMainMenuButtons();\n    void DrawConfirmButtons();\npublic:\n    void DrawToolTip();\n \n//Core\npublic:\n    APlayerController* ThePC;\n    void PlayerInputChecks();\nprotected:\n    //Draw HUD\n    void DrawHUD_Reset();\n    virtual void DrawHUD() OVERRIDE;\n \n    /** after all game elements are created */\n    virtual void PostInitializeComponents() OVERRIDE;\n \n \n};\n\n\n\n\n\n\n\n\n//CPP\n// Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.\n \n\n \n#include \"Game.h\"   //Replace with a reference to the header file of your own project\n \n#define BUTTONTYPE_MAIN_RESTART     1\n#define BUTTONTYPE_MAIN_EXIT         2\n \n#define BUTTONTYPE_CONFIRM_YES     1\n#define BUTTONTYPE_CONFIRM_NO     2\n \n#define CANVAS_WHITE if(Canvas) Canvas->SetDrawColor(FColor_White);\n \n//Cursor Draw Offset\n//        use this to position texture over the point of your cursor, \n//            if the point is not at exactly 0,0\n#define CURSOR_DRAW_OFFSET 3\n \n//\n//Static Consts\n//\n \nconst FString AJoyHUD::S_Title_Main            = FString(\"Joy!\"); \nconst FString AJoyHUD::S_Title_Confirm        = FString(\"Exit Game?\");\n \nconst FString AJoyHUD::S_Button_Restart    = FString(\"Restart\"); \nconst FString AJoyHUD::S_Button_Exit        = FString(\"Exit\"); \n \n// Colors \nconst FColor AJoyHUD::FColorBlack         = FColor(0,0,0,255);\nconst FColor AJoyHUD::FColorRed             = FColor(255,0,0,255);\nconst FColor AJoyHUD::FColorYellow         = FColor(255,255,0,255);\nconst FColor AJoyHUD::FColorBlue            = FColor(0,0,255,255);\nconst FColor AJoyHUD::FColor_White        = FColor(255,255,255,255);\n// Backgrounds \nconst FLinearColor AJoyHUD::LC_Black     = FLinearColor(0, 0, 0, 1);\nconst FLinearColor AJoyHUD::LC_Pink        = FLinearColor(1, 0, 1, 1);\nconst FLinearColor AJoyHUD::LC_Red         = FLinearColor(1, 0, 0, 1);\nconst FLinearColor AJoyHUD::LC_Yellow     = FLinearColor(1, 1, 0, 1);\n \nAJoyHUD::AJoyHUD(const class FPostConstructInitializeProperties& PCIP) : Super(PCIP)\n{\n    //Draw HUD?\n    DontDrawHUD         = false;\n \n    //States\n    ConfirmDialogOpen     = false;\n    InMainMenu             = true;\n \n    //Scale\n    GlobalHUDMult = 1;\n    DefaultFontScale = 0.7;   //scaling down a size 36 font\n \n    //     I recommend creating fonts at a high resolution / size like 36\n    //            then you can scale down the font as needed to any size of your choice\n \n    // this avoids needing to make multiple fonts for different sizes, but have a high\n    // resolution when you use larger font sizes\n \n}    \n \n//Core \n \nvoid AJoyHUD::PostInitializeComponents()\n{\n    Super::PostInitializeComponents();\n \n    //Establish the PC\n    ThePC = GetOwningPlayerController();\n \n    //How to get a ref to your custom PC\n    //AYourPlayerController* YourChar = Cast<AYourPlayerController>(ThePC);\n \n    //How to Get The Character\n    //AYourCharacterClass* YourChar = Cast<AYourCharacterClass>(GetOwningPawn());\n \n}\n \n//===============\n// Draw Dialogs\n//===============\nvoid AJoyHUD::DrawHUD_DrawDialogs()\n{\n    DrawMainMenu();\n    if(ConfirmDialogOpen) DrawConfirm();\n}\n//Menus\nvoid AJoyHUD::DrawMainMenu()\n{\n    //Background\n    DrawMaterialSimple(\n        MaterialBackground, \n        10, 10, \n        256, \n        512,\n        1.3\n    );\n \n    //Menu Title\n \n    //Draw buttons\n    DrawMainMenuButtons();\n}\nvoid AJoyHUD::DrawConfirm()\n{\n    //Blue rect with alpha 50%\n    DrawJoyRect(Canvas->SizeX/2 - 100, Canvas->SizeY/2 - 50,200,100,FLinearColor(0,0,1,0.2333));\n \n    //Confirm Title\n \n    //Draw buttons\n    DrawConfirmButtons();\n}\n \n//Buttons\nvoid AJoyHUD::DrawMainMenuButtons()\n{\n    //Start Point\n    float xStart = 100;\n    float yStart = 110;\n \n    //Background\n    VDrawTile(ButtonBackground,xStart,yStart,150,80,FColor(255,255,255,120)); //alpha 120/255\n \n    //Text\n    DrawJoyText(\n        VerdanaFont,\"Restart\",xStart+30,yStart+20,\n        LC_Black, DefaultFontScale,\n        true,LC_Red\n    );\n \n    //Struct\n    //Add Button If Necessary\n    //        could be cleared and need refreshing if using a different menu\n    //            clear buttons with ButtonsMain.Empty()\n    if (ButtonsMain.Num() < 1 )\n    {\n        FJoyButtonStruct newButton = FJoyButtonStruct();\n        newButton.type             = BUTTONTYPE_MAIN_RESTART;\n        newButton.toolTip        = \"Restart the Game!\";    \n        newButton.minX             = xStart;\n        newButton.maxX             = xStart + 150;        \n        newButton.minY             = yStart;\n        newButton.maxY             = yStart + 80;\n \n        //Add to correct array\n        ButtonsMain.Add(newButton);\n    }\n \n \n    xStart = 100;\n    yStart = 410;\n \n    VDrawTile(ButtonBackground,xStart,yStart,150,80,FColor(255,255,255,120)); //alpha 120/255\n \n    //Text\n    DrawJoyText(\n        VerdanaFont,\"Exit\",xStart+55,yStart+20,\n        LC_Black, DefaultFontScale,\n        true,LC_Red\n    );\n \n    if (ButtonsMain.Num() < 2 )\n    {\n        FJoyButtonStruct newButton = FJoyButtonStruct();\n        newButton.type             = BUTTONTYPE_MAIN_EXIT;\n        newButton.toolTip            = \"Exit the Game!\";    \n        newButton.minX             = xStart;\n        newButton.maxX             = xStart + 150;        \n        newButton.minY             = yStart;\n        newButton.maxY             = yStart + 80;\n \n        //Add to correct array\n        ButtonsMain.Add(newButton);\n    }\n}\nvoid AJoyHUD::DrawConfirmButtons()\n{\n    float xStart = Canvas->SizeX/2 - 100;\n    float yStart = Canvas->SizeY/2 - 40;\n \n    //Highlighted?\n    if(ActiveButton_Type == BUTTONTYPE_CONFIRM_YES ) ColorPtr = &LC_Pink;\n    else ColorPtr = &LC_Yellow;\n \n    //Text\n    DrawJoyText(\n        VerdanaFont,\"Yes\",xStart+30,yStart+20,\n        *ColorPtr, DefaultFontScale,\n        true\n    );\n \n    if (ButtonsConfirm.Num() < 1 )\n    {\n        FJoyButtonStruct newButton = FJoyButtonStruct();\n        newButton.type             = BUTTONTYPE_CONFIRM_YES ;\n        newButton.toolTip            = \"\";    \n        newButton.minX             = xStart;\n        newButton.maxX             = xStart + 75;        \n        newButton.minY             = yStart + 20;\n        newButton.maxY             = yStart + 60;\n \n        //could use GetTextSize to streamline this\n \n        //Add to correct array\n        ButtonsConfirm.Add(newButton);\n    }\n \n    xStart = Canvas->SizeX/2 + 20;\n    yStart = Canvas->SizeY/2 - 40;\n \n    //Highlighted?\n    if(ActiveButton_Type == BUTTONTYPE_CONFIRM_NO) ColorPtr = &LC_Black;\n    else ColorPtr = &LC_Yellow;\n \n    //Text\n    DrawJoyText(\n        VerdanaFont,\"No\",xStart+30,yStart+20,\n        *ColorPtr, DefaultFontScale,\n        true\n    );\n \n    if (ButtonsConfirm.Num() < 2 )\n    {\n        FJoyButtonStruct newButton = FJoyButtonStruct();\n        newButton.type             = BUTTONTYPE_CONFIRM_NO;\n        newButton.toolTip            = \"\";    \n        newButton.minX             = xStart;\n        newButton.maxX             = xStart + 75;        \n        newButton.minY             = yStart + 20;\n        newButton.maxY             = yStart + 60;\n \n        //could use GetTextSize to streamline this\n \n        //Add to correct array\n        ButtonsConfirm.Add(newButton);\n    }\n}\n \n//===============\n// Cursor In Buttons\n//===============\nint32 AJoyHUD::CheckCursorInButton(const TArray<FJoyButtonStruct>& ButtonArray)\n{\n    for(int32 b = 0; b < ButtonArray.Num(); b++)\n    {\n        CurCheckButton = &ButtonArray[b];\n \n        //check cursor in bounds\n        if (CurCheckButton->minX <= MouseLocation.X && MouseLocation.X <= CurCheckButton->maxX &&\n            CurCheckButton->minY <= MouseLocation.Y && MouseLocation.Y <= CurCheckButton->maxY )\n        {\n \n            //Active Button Type\n            ActiveButton_Type = CurCheckButton->type; \n \n            //Tool Tip\n            ActiveButton_Tip = CurCheckButton->toolTip; \n \n            //Change Cursor\n            CursorHoveringInButton = true;\n \n            //Mouse Clicked?\n            if (ThePC->WasInputKeyJustPressed(EKeys::LeftMouseButton))\n            {\n                return ActiveButton_Type;\n                //~~\n                //no need to check rest of buttons\n            }\n        }\n    }\n \n    //No Click Occurred This Tick\n    return -1;    \n}\n \n//Check Confirm\nvoid AJoyHUD::CheckCursorInButtonsConfirm()\n{\n    //Check Confirm Buttons\n    ClickedButtonType = CheckCursorInButton(ButtonsConfirm); //fills global ActiveButton_Type\n \n    if(ClickedButtonType == BUTTONTYPE_CONFIRM_YES )\n    {\n        ThePC->ConsoleCommand(\"Exit\");\n        return;\n    }\n    if(ClickedButtonType == BUTTONTYPE_CONFIRM_NO)\n    {\n        ConfirmDialogOpen = false;\n        ButtonsConfirm.Empty(); //Buttons not needed anymore\n        return;\n    }\n}\n \n//Check Buttons\nvoid AJoyHUD::CheckCursorInButtonsMain()\n{\n    //Check Confirm Buttons\n    ClickedButtonType = CheckCursorInButton(ButtonsMain);\n \n    if(ClickedButtonType == BUTTONTYPE_MAIN_RESTART )\n    {\n        ThePC->ConsoleCommand(\"RestartLevel\");\n        return;\n    }\n    if(ClickedButtonType == BUTTONTYPE_MAIN_EXIT)\n    {\n        ConfirmDialogOpen = true;\n        return;\n    }\n}\nvoid AJoyHUD::DrawHUD_CheckCursorInButtons()\n{\n    if(ConfirmDialogOpen)\n    {\n        CheckCursorInButtonsConfirm();\n \n        //Take Focus Away From All Other buttons\n        return; \n        //~\n    }\n \n    //Main\n    CheckCursorInButtonsMain();\n}\n \nvoid AJoyHUD::DrawToolTip()\n{\n    //if mouse is too far to right, draw from left instead\n    float xStart = MouseLocation.X + 150;\n    float yStart = MouseLocation.Y + 5;\n \n    //out vars\n    float RV_xLength; \n    float RV_yLength;\n    //Text Size\n    GetTextSize(\n        ActiveButton_Tip, \n        RV_xLength, \n        RV_yLength, \n        UE4Font,\n        DefaultFontScale * 2\n    );\n \n    // Decide Draw to Left or to the Right \n \n    //Draw to the Left\n    if (xStart + RV_xLength >= Canvas->SizeX - 40)\n    {\n        xStart -= 150 + 140 + 64 + RV_xLength;\n \n        //If Text is too long, bring it closer to the cursor\n        if(xStart < 33 ) xStart = 33;\n    }\n \n    //Background\n    DrawJoyRect(\n        xStart, yStart, \n        RV_xLength + 70, \n        80, \n        FLinearColor(0, 0, 1, 0.7) //alpha 0.7\n    );\n \n    //Tool Tip\n    DrawText(\n        ActiveButton_Tip, \n        LC_Pink,\n        xStart + 32, yStart + 20,\n        UE4Font,\n        DefaultFontScale * 2,            \n        false        //scale position of message with HUD scale\n    );\n}\nvoid AJoyHUD::DrawHUD_DrawCursor()\n{\n    //Tool Tip\n    if(ActiveButton_Tip != \"\") DrawToolTip();\n \n    //Cursor Hovering in a Button?\n    if (CursorHoveringInButton)\n    {\n        //pointer tex found?\n        if (!CursorHoveringButton) return;\n        DrawFullSizeTile(CursorHoveringButton, MouseLocation.X - CURSOR_DRAW_OFFSET, MouseLocation.Y - CURSOR_DRAW_OFFSET, FColor_White );\n    }\n \n    else\n    {\n        //cursor tex found?\n        if(!CursorMain) return;\n        DrawFullSizeTile(CursorMain, MouseLocation.X - CURSOR_DRAW_OFFSET, MouseLocation.Y - CURSOR_DRAW_OFFSET, FColor_White );\n    }\n}\n \nvoid AJoyHUD::PlayerInputChecks()\n{\n    //check out this tutorial of mine for a list of all EKeys::\n    //http://forums.epicgames.com/threads/972861-Tutorials-C-for-UE4-Code-Samples-gt-gt-New-Video-Freeze-Render-When-Tabbed-Out?p=31660286&viewfull=1#post31660286\n \n    if(ThePC->WasInputKeyJustPressed(EKeys::Escape))\n    {\n        SetCursorMoveOnly(false);\n        return;\n    }\n    if(ThePC->WasInputKeyJustPressed(EKeys::F))\n    {\n        SetCursorMoveOnly(!ThePC->IsLookInputIgnored());\n        return;\n    }\n    if(ThePC->WasInputKeyJustPressed(EKeys::H))\n    {\n        DontDrawHUD = !DontDrawHUD;\n        return;\n    }\n \n    //Confirm\n    if(ConfirmDialogOpen)\n    {\n        if(ThePC->WasInputKeyJustPressed(EKeys::Y))\n        {\n            ThePC->ConsoleCommand(\"Exit\"); \n            //could replace with function based on confirm context\n \n            return;\n        }\n        if(ThePC->WasInputKeyJustPressed(EKeys::N))\n        {\n            ConfirmDialogOpen = false;\n            ButtonsConfirm.Empty(); //Buttons not needed anymore\n            //Cancel Confirm\n \n            return;\n        }\n    }\n}\n \nvoid AJoyHUD::DrawHUD_Reset()\n{\n    ActiveButton_Type         = -1;\n    ActiveButton_Tip         = \"\";\n    CursorHoveringInButton     = false;\n}\n \nvoid AJoyHUD::DrawHUD()\n{\n    //==============================\n    //==============================\n    //==============================\n    //Have PC for Input Checks and Mouse Cursor?\n    if(!ThePC)\n    {\n        //Attempt to Reacquire PC\n        ThePC = GetOwningPlayerController();\n \n        //Could Not Obtain PC\n        if(!ThePC) return;\n        //~~\n    }\n \n    //Multiplayer Safety Check\n    if(!ThePC->PlayerInput) return; //not valid for first seconds of a multiplayer client\n    //~~\n    //==============================\n    //==============================\n    //==============================\n \n    //Player Input\n    PlayerInputChecks();\n \n    //Draw HUD?\n    if(DontDrawHUD) return;\n    //~~\n \n    //Super\n    Super::DrawHUD();\n \n    //No Canvas?\n    if(!Canvas) return;\n    //\n \n    //Reset States\n    DrawHUD_Reset();\n \n    //================\n    //Get New Mouse Position\n    //================\n    ThePC->GetMousePosition(MouseLocation.X,MouseLocation.Y);\n \n    //Cursor In Buttons\n    DrawHUD_CheckCursorInButtons();\n \n    //Draw Dialogs\n    DrawHUD_DrawDialogs();\n \n    //### Do Last ###\n    //Draw Cursor\n    DrawHUD_DrawCursor();\n \n    //Debugging Info\n    //ThePC->ClientMessage(\"HUD Loop Completed!\");\n}\n\n\n//If it all compiles you need to make a HUD blueprint in the editor\nthen go to your GameMode.cpp and add this\n\nAYourGameMode::AYourGameMode(const class FPostConstructInitializeProperties& PCIP)\n    : Super(PCIP)\n{\n    // You can obtain the asset path of your HUD blueprint through the editor \n    // by right-clicking the Blueprint asset and choosing \"Copy Reference\".\n    // You should then add the \"_C\" suffix so that the class finder properly \n    // points to the actual class used by the game, as opposed to its Blueprint\n    // which is an editor-only concept).\n    // \n    // For instance, given a blueprint named BP_JoyHUD, the class path would be\n    //    \"/Game/Blueprints/BP_JoyHUD_C\"\n    static ConstructorHelpers::FClassFinder<AHUD> TheHUDOb(TEXT(\"/Game/Blueprints/BP_JoyHUD_C\"));\n    if (TheHUDOb.Class != NULL)\n    {\n        HUDClass = TheHUDOb.Class;\n    }\n}\n\n//Now you can add your graphics from the tab in your new HUD bp"
  },
  {
    "name": "Widget class",
    "info": "Some sort of headsup-display but you can it takes up a part of the screen instead of the whole screen. (can also be nested)",
    "content": "//In your <game.h> header file add these lines\n#include \"Runtime/UMG/Public/UMG.h\"\n#include \"Runtime/UMG/Public/UMGStyle.h\"\n#include \"Runtime/UMG/Public/Blueprint/UserWidget.h\"\n#include \"Runtime/UMG/Public/Slate/SObjectWidget.h\"\n#include \"Runtime/UMG/Public/IUMGModule.h\"\n\n//In your <game.Build.cs> file add this line\nPublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"UMG\", \"Slate\", \"SlateCore\" });\n\n//Now we can use UMG in our code (make sure it compiles)\n\n//Open YourPlayerController.h\nUCLASS()\nclass MYPROJECT_API AMyPlayerController : public APlayerController\n{\n    GENERATED_BODY()\n \npublic:\n    // Note: that am using forward declaration Because am not including the\n    // widget in the header and to prevent circular dependency.\n    // you dont need to do that if you include the Widget Class in the .h\n    // forward declaration is just putting \"class\" before the class name so the compiler know its a\n    // class but its not included in the header and don't freak out. Ex. class UUserWidget\n \n    // Reference UMG Asset in the Editor\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Widgets\")\n    TSubclassOf<class UUserWidget> wMainMenu;\n \n    // Variable to hold the widget After Creating it.\n    UUserWidget* MyMainMenu;\n \n    // Override BeginPlay()\n    virtual void BeginPlay() override;\n \n};\n\n//YourPlayerController.cpp\n#include \"Blueprint/UserWidget.h\"\n/* Add this in the BeginPlay function*/\nvoid AMyPlayerController::BeginPlay()\n{\n    Super::BeginPlay();\n \n    if (wMainMenu) // Check if the Asset is assigned in the blueprint.\n    {\n        // Create the widget and store it.\n        MyMainMenu = CreateWidget<UUserWidget>(this, wMainMenu);\n \n        // now you can use the widget directly since you have a referance for it.\n        // Extra check to  make sure the pointer holds the widget.\n        if (MyMainMenu)\n        {\n            //let add it to the view port\n            MyMainMenu->AddToViewport();\n        }\n \n        //Show the Cursor.\n        bShowMouseCursor = true;\n    }\n \n}\n\n/* Now create a PlayerController that inherits from this class (BluePrint)\nAnd use that playerController. Open the playerController and assign the widget you wish to use*/"
  },
  {
    "name": "Blueprint function library",
    "info": "This is used if you need functions you can't use in blueprints by default (own c++ functions or dvanced default logic that isn't in blueprint",
    "content": "//Create a blueprint function class\n//These functions are globaly available in blueprints\n\n//Header\nUCLASS()\nclass UAnalyticsBlueprintLibrary :\n    public UBlueprintFunctionLibrary\n{\n    GENERATED_UCLASS_BODY()\n    /** Starts an analytics session without any custom attributes specified */\n    UFUNCTION(BlueprintCallable, Category=\"Analytics\")\n    static bool StartSession();\n    /*Could be made in BluePrints but would be slower than c++*/\n    UFUNCTION(BlueprintCallable, Category=\"Analytics\")\n    static AAIController* GetAIController(AActor* ControlledActor);\n\n//cpp\nbool UAnalyticsBlueprintLibrary::StartSession()\n{\n    TSharedPtr<IAnalyticsProvider> Provider = FAnalytics::Get().GetDefaultConfiguredProvider();\n    if (Provider.IsValid())\n    {\n        return Provider->StartSession();\n    }\n    else\n    {\n        UE_LOG(LogAnalyticsBPLib, Warning, TEXT(\"StartSession: Failed to get the default analytics provider. Double check your [Analytics] configuration in your INI\"));\n    }\n    return false;\n}\n\nAAIController* UAIBlueprintHelperLibrary::GetAIController(AActor* ControlledActor)\n{\n    APawn* AsPawn = Cast<APawn>(ControlledActor);\n    if (AsPawn != nullptr)\n    {\n        return Cast<AAIController>(AsPawn->GetController());\n    }\n    return Cast<AAIController>(ControlledActor);\n}"
  }
]